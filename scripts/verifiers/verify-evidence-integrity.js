/**
 * verify-evidence-integrity.js - Detect stub vs real evidence
 *
 * Verifies that evidence directories contain ACTUAL captured content,
 * not just agent-written metadata summaries.
 *
 * Stub evidence indicators:
 * - metadata.json has "summary", "key_facts", "key_claims" fields (LLM-written)
 * - metadata.json lacks "files" field with hashes
 * - metadata.json lacks "method" (firecrawl, playwright, etc.)
 * - metadata.json lacks "_capture_signature" (v2 captures)
 * - No actual content files (capture.html, capture.md, capture.png)
 *
 * Real evidence indicators:
 * - metadata.json has "files" field with paths and hashes
 * - metadata.json has "method", "http_status", "capture_duration_ms"
 * - metadata.json has "_capture_signature" (proves script execution)
 * - Actual content files exist and match metadata
 *
 * CRITICAL: The _capture_signature field is cryptographically generated by
 * the capture script and CANNOT be faked by an LLM.
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Must match firecrawl-capture.js
const CAPTURE_SIGNATURE_VERSION = 'v2';
const CAPTURE_SALT = 'firecrawl-capture-2026-integrity';

/**
 * Verify capture signature - returns true if signature is valid
 */
function verifyCaptureSignature(meta) {
  if (!meta._capture_signature || !meta.files) return false;

  const fileHashesSorted = Object.values(meta.files)
    .map(f => f.hash)
    .filter(Boolean)
    .sort()
    .join('|');

  const signatureInput = [
    meta._signature_version || CAPTURE_SIGNATURE_VERSION,
    meta.source_id,
    meta.url,
    meta.captured_at,
    fileHashesSorted,
    CAPTURE_SALT
  ].join(':');

  const expectedSig = `sig_${meta._signature_version || CAPTURE_SIGNATURE_VERSION}_${crypto.createHash('sha256').update(signatureInput).digest('hex').slice(0, 32)}`;

  return meta._capture_signature === expectedSig;
}

module.exports = {
  name: 'evidence-integrity',
  description: 'Verify evidence is real captures, not agent-written stubs',

  run(caseDir) {
    const webDir = path.join(caseDir, 'evidence', 'web');
    const gaps = [];

    if (!fs.existsSync(webDir)) {
      return { passed: true, gaps: [] }; // No web evidence yet
    }

    const sourceDirs = fs.readdirSync(webDir)
      .filter(d => fs.statSync(path.join(webDir, d)).isDirectory())
      .sort();

    let stubCount = 0;
    let validCount = 0;

    for (const sourceId of sourceDirs) {
      const sourceDir = path.join(webDir, sourceId);
      const metaPath = path.join(sourceDir, 'metadata.json');

      if (!fs.existsSync(metaPath)) {
        gaps.push({
          type: 'MISSING_METADATA',
          severity: 'HIGH',
          source_id: sourceId,
          description: `Evidence folder ${sourceId} has no metadata.json`,
          remediation: `Run capture: node scripts/capture.js ${sourceId} <url> ${caseDir}`
        });
        continue;
      }

      try {
        const meta = JSON.parse(fs.readFileSync(metaPath, 'utf-8'));
        const analysis = analyzeMetadata(meta, sourceDir);

        if (analysis.isStub) {
          stubCount++;
          gaps.push({
            type: 'STUB_EVIDENCE',
            severity: 'BLOCKER',
            source_id: sourceId,
            description: `${sourceId} is stub evidence (agent-written summary, not actual capture)`,
            indicators: analysis.stubIndicators,
            url: meta.url || 'unknown',
            remediation: `Re-capture with: node scripts/capture.js ${sourceId} "${meta.url}" ${caseDir}`
          });
        } else if (analysis.issues.length > 0) {
          gaps.push({
            type: 'EVIDENCE_ISSUES',
            severity: 'MEDIUM',
            source_id: sourceId,
            description: `${sourceId} has evidence integrity issues`,
            issues: analysis.issues
          });
        } else {
          validCount++;
        }
      } catch (e) {
        gaps.push({
          type: 'INVALID_METADATA',
          severity: 'HIGH',
          source_id: sourceId,
          description: `Failed to parse metadata.json: ${e.message}`
        });
      }
    }

    const passed = stubCount === 0;

    return {
      passed,
      gaps,
      summary: {
        total_sources: sourceDirs.length,
        valid_captures: validCount,
        stub_evidence: stubCount,
        issues: gaps.filter(g => g.type === 'EVIDENCE_ISSUES').length
      }
    };
  }
};

/**
 * Analyze metadata to determine if it's a stub or real capture
 */
function analyzeMetadata(meta, sourceDir) {
  const stubIndicators = [];
  const realIndicators = [];
  const issues = [];

  // DEFINITIVE stub indicators - things ONLY agents write, scripts NEVER write
  if (meta.summary) stubIndicators.push('has "summary" field (LLM-written, scripts never generate this)');
  if (meta.key_facts) stubIndicators.push('has "key_facts" field (LLM-written)');
  if (meta.key_claims) stubIndicators.push('has "key_claims" field (LLM-written)');
  if (meta.category) stubIndicators.push('has "category" field (LLM-written)');
  if (meta.credibility) stubIndicators.push('has "credibility" field (LLM-written)');
  if (meta.relevance) stubIndicators.push('has "relevance" field (LLM-written)');
  if (meta.independence) stubIndicators.push('has "independence" field (LLM-written)');
  if (meta.reliability) stubIndicators.push('has "reliability" field (LLM-written)');
  if (meta.key_claims_supported) stubIndicators.push('has "key_claims_supported" field (LLM-written)');
  if (meta.id && !meta.source_id) stubIndicators.push('uses "id" instead of "source_id"');

  // Check for capture signature (v2+ captures)
  if (meta._capture_signature) {
    const signatureValid = verifyCaptureSignature(meta);
    if (signatureValid) {
      realIndicators.push('has VALID capture signature (proves script execution)');
    } else {
      stubIndicators.push('has INVALID capture signature (tampered or faked)');
    }
  }

  // Real capture indicators - things scripts write
  if (meta.files && typeof meta.files === 'object' && Object.keys(meta.files).length > 0) {
    realIndicators.push(`has "files" field with ${Object.keys(meta.files).length} entries`);
  } else if (meta.files && Object.keys(meta.files).length === 0) {
    stubIndicators.push('has empty "files" object (capture failed or stub)');
  }

  if (meta.method) realIndicators.push(`has "method" (${meta.method})`);
  if (meta.http_status) realIndicators.push(`has "http_status" (${meta.http_status})`);
  if (meta.capture_duration_ms) realIndicators.push('has "capture_duration_ms"');
  if (meta.firecrawl_version) realIndicators.push(`has "firecrawl_version" (${meta.firecrawl_version})`);

  // Check for actual content files
  const contentFiles = ['capture.html', 'capture.md', 'capture.png', 'capture.pdf', 'content.html', 'content.md'];
  const foundFiles = contentFiles.filter(f => fs.existsSync(path.join(sourceDir, f)));

  if (foundFiles.length > 0) {
    realIndicators.push(`has content files: ${foundFiles.join(', ')}`);
  } else {
    stubIndicators.push('no content files found (capture.html, capture.md, etc.)');
  }

  // Verify files field matches actual files
  if (meta.files && typeof meta.files === 'object') {
    for (const [type, info] of Object.entries(meta.files)) {
      if (info && info.path) {
        const filePath = path.join(sourceDir, info.path);
        if (!fs.existsSync(filePath)) {
          issues.push(`metadata.files.${type}.path="${info.path}" but file doesn't exist`);
        }
      }
    }
  }

  // STRICT DECISION LOGIC:
  // 1. If ANY definitive stub indicator exists → stub
  // 2. If no content files AND no valid files hash → stub
  // 3. If has valid capture signature → real (overrides heuristics)
  const hasDefinitiveStubIndicator = stubIndicators.some(s =>
    s.includes('LLM-written') || s.includes('INVALID capture signature')
  );
  const hasValidSignature = realIndicators.some(r => r.includes('VALID capture signature'));
  const hasNoContent = foundFiles.length === 0 &&
                       (!meta.files || Object.keys(meta.files).length === 0);

  const isStub = hasDefinitiveStubIndicator ||
                 (hasNoContent && !hasValidSignature) ||
                 (stubIndicators.length > 0 && realIndicators.length === 0);

  return {
    isStub,
    stubIndicators,
    realIndicators,
    issues,
    hasValidSignature
  };
}
